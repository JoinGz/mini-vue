## reactivity总体实现

代理对象的本质，就是查阅规范并找到可拦截的基本操作的方法。有一些操作并不是基本操作，而是复合操作，这需要我们查阅规范了解它们都依赖哪些基本操作，从而通过基本操作的拦截方法间接地处理复合操作。

### object

 主要对get,set的代理处理。
 对于for in的收集一个特殊的key(iterate_key)。在新增、删除的时候需要触发。值改变的时候不用，因为如果依赖这个值，那么是会收集到响应的。

### array
  数组一些操作也会触发get,set。
  对于数组length的变更，我们需要注意。需要多触发一些依赖如：`arr = [0,1]`
  当执行`arr.length = 1`时，如果之前收集了`arr[1]`的依赖就需要重新拿来执行下。（值已变更）
  for in也是和数组length挂钩，因为变更会使的length也变更。对于for of 。for...of 基于迭代协议工作，数组内建了Symbol.iterator 方法。根据规范的 23.1.5.1 节可知，数组迭代器执行时，会读取数组的 length 属性或数组的索引。因此，我们不需要做其他额外的处理，就能够实现对 for...of 迭代的响应式支持。

  对于数组的查找方法，如果是一个对象，那么我们返回就是一个ractive(obj),导致数组无法找到对应的值。
  `a = {}; arr = [a]`
  如：arr.includes(a)->流程
  includes内部会取出`arr[0]`来对比是否相等。此时就生成了一个ractive(a)
  然后执行includes(a)。ractive(a) !== a 为false。我们的处理办法：写了一层处理在代理对象里面没有时就去原对象里面查找。arr.includes(a) ==> true

  其中很多方法会隐私变更length属性，所以有一些特殊的处理。

### Map、Set

  在访问这些对象时，会间接访问到内部方法。所以需要正确的转发过去。对this也是同理。
  `Map,Set`通过get、set、add等方法来处理。所以我们重写了这些方法，使其正确的收集触发依赖。


